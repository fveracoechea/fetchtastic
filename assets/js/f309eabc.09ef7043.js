"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[324],{84:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=r(6106),t=r(9252);const o={title:"Error Handling",sidebar_position:3},a=void 0,c={id:"error-handling",title:"Error Handling",description:"The problem",source:"@site/docs/error-handling.mdx",sourceDirName:".",slug:"/error-handling",permalink:"/fetchtastic/docs/error-handling",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/error-handling.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Error Handling",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Usage Guide",permalink:"/fetchtastic/docs/usage-guide"},next:{title:"API Reference",permalink:"/fetchtastic/docs/category/api-reference"}},i={},l=[{value:"The problem",id:"the-problem",level:2},{value:"The solution",id:"the-solution",level:2},{value:"Fallback response",id:"fallback-response",level:3},{value:"Replaying requests",id:"replaying-requests",level:3},{value:"Reusable error-catchers",id:"reusable-error-catchers",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"the-problem",children:"The problem"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",children:"fetch"})," in\nJavaScript is awesome."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const res = await fetch('/user');\nconst user = await res.json();\n"})}),"\n",(0,s.jsx)(n.p,{children:"While nice and simple, this code has a number of issues."}),"\n",(0,s.jsx)(n.p,{children:"You could say \u201coh, yeah, handle errors\u201d, and rewrite it like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"try {\n  const res = await fetch('/user');\n  const user = await res.json();\n} catch (err) {\n  // Handle the error\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is an improvement, but still has issues."}),"\n",(0,s.jsxs)(n.p,{children:["Here, we\u2019re assuming user is in fact a user object, as well that we got a ",(0,s.jsx)(n.code,{children:"200"}),"\nresponse. Fetch does not throw errors for non-200 statuses, so you could have\nactually received a ",(0,s.jsx)(n.code,{children:"400"}),", ",(0,s.jsx)(n.code,{children:"401"}),", ",(0,s.jsx)(n.code,{children:"404"}),", ",(0,s.jsx)(n.code,{children:"500"}),", or all kinds of other issues."]}),"\n",(0,s.jsx)(n.p,{children:"That's why manually checking and handling every request error code can be very\ntedious:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"try {\n  const response = await fetch('/anything');\n\n  if (!response.ok) {\n    switch (response.status) {\n      case 400:\n        // bad request\n        break;\n\n      case 401:\n        // not authorized\n        break;\n\n      case 404:\n        // not found\n        break;\n\n      case 500:\n        // internal server error\n        break;\n    }\n  }\n} catch (error) {\n  // Another error\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-solution",children:"The solution"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fetchtastic"})," throws an ",(0,s.jsx)(n.a,{href:"/docs/reference/response-error",children:"ResponseError"})," when\nthe response is not successful and contains helper methods to handle common\ncodes."]}),"\n",(0,s.jsxs)(n.p,{children:["We call those helper methods\n",(0,s.jsx)(n.a,{href:"/docs/reference/fetchtastic#error-catchers",children:"Error Catchers"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"try {\n  const request = new Fetchtastic('...');\n\n  const response = await request\n    .badRequest(error => /* 400 */)\n    .unauthorized(error => /* 401 */)\n    .forbidden(error => /* 403 */)\n    .notFound(error => /* 404 */)\n    .timeout(error => /* 408 */)\n    .serverError(error => /* 500 */)\n    .onError(429, error => /* Too many requests */)\n    .onError(501, error => /* Not implemented */)\n    .resolve();\n\n} catch (error) {\n  /* Uncaught errors */\n  if (error instanceof ResponseError) {\n    console.log(error.url);\n    console.log(error.status); // 418\n    console.log(error.message); // I'm a Teapot\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"fallback-response",children:"Fallback response"}),"\n",(0,s.jsx)(n.p,{children:"An alternative response can be returned from error catchers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const resource = new Fetchtastic('/api/attributes')\n  .notFound(() =>\n    Response.json({\n      message: 'No data has been found',\n    }),\n  )\n  .json();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"replaying-requests",children:"Replaying requests"}),"\n",(0,s.jsx)(n.p,{children:"We can perform an additional request, and modify the initial response if needed."}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, you can notice that the execution flow is preserved as\nexpected, ",(0,s.jsx)(n.code,{children:".json()"})," will return the result of the original request or the\nreplayed one."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const api = new Fetchtastic('/api');\n\nconst sleep = (time: number) =>\n  new Promise(resolve => setTimeout(resolve, time));\n\nexport function getResource(id: number) {\n  return api\n    .get(`/resource/${id}`)\n    .onError(429, async (error, request) => {\n      // Too many requests\n      console.warn(error.message);\n      // wait 3 seconds\n      await sleep(3000);\n      // Replay the original request\n      return request.resolve();\n    })\n    .json();\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"reusable-error-catchers",children:"Reusable error-catchers"}),"\n",(0,s.jsxs)(n.p,{children:["The original ",(0,s.jsx)(n.code,{children:"request"})," is passed along the error and can be used to create\nreusable functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const api = new Fetchtastic('/api')\n  .appendHeader('Content-Type', 'application/json')\n  .appendHeader('Authorization', getToken());\n\nasync function handleUnauthorized(error: ResponseError, request: Fetchtastic) {\n  // Renew credentials\n  const credentials = await api.get('/renew-token').json();\n  saveToken(credentials.token);\n  // Replay the original request with new credentials\n  return request.headers({ Authorization: credentials.token }).resolve();\n}\n\nconst posts = api.url('/posts').unauthorized(handleUnauthorized);\n\nconst albums = api.url('/albums').unauthorized(handleUnauthorized);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},9252:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var s=r(7378);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);