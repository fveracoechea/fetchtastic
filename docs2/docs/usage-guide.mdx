---
title: 'Usage Guide'
sidebar_position: 2
---

## Basic example

```typescript
const api = new Fetchtastic('https://jsonplaceholder.typicode.com')
  .setOptions({ cache: 'default', mode: 'cors' })
  .headers({
    Accept: 'application/json',
    'Content-Type': 'application/json',
  });

// get request
const albums = await api
  .get('/albums')
  .searchParams({ page: 1, per_page: 12 })
  .json();

// post request
await api.post('/albums', { title: 'My New Album' }).resolve();
```

## Composable configuration

You can safely reuse previous instances. All methods return a new instance and
does not modify the previous one.

### 1. Global config

```typescript
const api = new Fetchtastic('/api/v2')
  .appendHeader('Accept', 'application/json')
  .setOptions({ credentials: 'include', mode: 'cors' });
```

### 2. Endpoint level config

```typescript
const postsApi = api
  .url('/post')
  .searchParams({ sortBy: 'date', order: 'desc' });

const albumsApi = api
  .url('/albums')
  .appendHeader('Content-Type', 'application/json');
```

### 3. Send Requests

```typescript
const posts = await postsApi.get().json();

const album = await albumsApi.get('/10').json();
```

## Aborting a request

Fetch has the ability to abort requests using AbortController and signals under
the hood. Compatible with browsers that support
[AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
Otherwise, you could use a
[polyfill](https://www.npmjs.com/package/abortcontroller-polyfill).

```typescript
const controller = new AbortController();
const api = new Fetchtastic('https://jsonplaceholder.typicode.com');

api
  .controller(controller)
  .get('/posts/1/comments')
  .json()
  .then(data => storeData(data)) // should never be called
  .catch((e: Error) => {
    console.log(e.name); // AbortError
    console.log(e.message); // The user aborted a request.
  });
// Abort it!
controller.abort();
```

With this pattern you can also associate the same controller with multiple
requests:

```typescript
const controller = new AbortController();

api.controller(controller).get('/posts').json();
api.controller(controller).get('/comments').json();
// Abort both requests
controller.abort();
```

## Type-safety

By default, the `json()` method returns an `unknown` type, however there are two
ways to infer type-safety for the resulting data types.

### Generic types

By providing a
[generic](https://www.typescriptlang.org/docs/handbook/2/generics.html) type
argument to `.json()` the resulting type will inferred:

```typescript
type Post = {
  id: number;
  title: string;
  body: string;
};

const request = new Fetchtastic('https://jsonplaceholder.typicode.com');

const post = await request.get('/posts/3').json<Post>();
```

### Runtime schema validation

You can provide a function to the `json()` resolver that performs runtime
validations in order to assert the returned type. Next are two examples to
achieve that:

#### [Type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)

```typescript
type Post = {
  id: number;
  title: string;
  body: string;
};

function isPost(data: unknown): data is Post {
  return (
    data != null &&
    typeof data === 'object' &&
    'title' in data &&
    typeof data.title === 'string' &&
    'body' in data &&
    typeof data.body === 'string'
  );
}

export function assertIsPost(data: unknown) {
  if (isPost(data)) return data;
  else throw new Error('Invalid data');
}

const request = new Fetchtastic('https://jsonplaceholder.typicode.com');

const post = await request.get('/posts/3').json(assertIsPost);
```

#### [Zod](https://zod.dev/)

```typescript
import { z } from 'zod';

const PostSchema = z.object({
  id: z.number(),
  title: z.string(),
  body: z.string(),
});

const post = await new Fetchtastic().get('/posts/5').json(PostSchema.parse);
```
