---
title: 'Error Handling'
sidebar_position: 3
---

## The problem

[fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) in
JavaScript is awesome.

```typescript
const res = await fetch('/user');
const user = await res.json();
```

While nice and simple, this code has a number of issues.

You could say “oh, yeah, handle errors”, and rewrite it like this:

```typescript
try {
  const res = await fetch('/user');
  const user = await res.json();
} catch (err) {
  // Handle the error
}
```

It is an improvement, but still has issues.

Here, we’re assuming user is in fact a user object, as well that we got a `200`
response. Fetch does not throw errors for non-200 statuses, so you could have
actually received a `400`, `401`, `404`, `500`, or all kinds of other issues.

That's why manually checking and handling every request error code can be very
tedious:

```typescript
try {
  const response = await fetch('/anything');

  if (!response.ok) {
    switch (response.status) {
      case 400:
        // bad request
        break;

      case 401:
        // not authorized
        break;

      case 404:
        // not found
        break;

      case 500:
        // internal server error
        break;
    }
  }
} catch (error) {
  // Another error
}
```

## The solution

**Fetchtastic** throws an [HttpError](/reference/http-error) when the response
is not successful and contains helper methods to handle common codes.

We call those helper methods
[Error Catchers](/reference/fetchtastic#error-catchers):

```typescript
try {
  const request = new Fetchtastic('...');

  const response = await request
    .badRequest(error => /* 400 */)
    .unauthorized(error => /* 401 */)
    .forbidden(error => /* 403 */)
    .notFound(error => /* 404 */)
    .timeout(error => /* 408 */)
    .serverError(error => /* 500 */)
    .onError(429, error => /* Too many requests */)
    .onError(501, error => /* Not implemented */)
    .resolve();

} catch (error) {
  /* Uncaught errors */
  if (error instanceof HttpError) {
    console.log(error.url);
    console.log(error.status); // 418
    console.log(error.message); // I'm a Teapot
  }
}
```

### Fallback response

An alternative response can be returned from error catchers.

```typescript
const resource = new Fetchtastic('/api/attributes')
  .notFound(() =>
    Response.json({
      message: 'No data has been found',
    }),
  )
  .json();
```

### Replaying requests

We can perform an additional request, and modify the initial response if needed.

In the following example, you can notice that the execution flow is preserved as
expected, `.json()` will return the result of the original request or the
replayed one.

```typescript
const api = new Fetchtastic('/api')
  .appendHeader('Content-Type', 'application/json')
  .appendHeader('Authorization', getToken());

const sleep = (time: number) =>
  new Promise(resolve => setTimeout(resolve, time));

export function getResource(id: number) {
  return resource
    .get(`/resource/${id}`)
    .onError(429, async (error, request) => {
      // Too many requests
      console.warn(error.message);
      // wait 2 seconds
      await sleep(2000);
      // Replay the original request
      return request.resolve();
    })
    .json();
}
```

### Reusable error-catchers

The original `request` is passed along the error and can be used to create
reusable functions:

```typescript
const api = new Fetchtastic('/api')
  .appendHeader('Content-Type', 'application/json')
  .appendHeader('Authorization', getToken());

async function handleUnauthorized(error: HttpError, request: Fetchtastic) {
  // Renew credentials
  const credentials = await api.get('/renew-token').json();
  saveToken(credentials.token);
  // Replay the original request with new credentials
  return request.headers({ Authorization: credentials.token }).resolve();
}

const posts = api.url('/posts').unauthorized(handleUnauthorized);

const albums = api.url('/albums').unauthorized(handleUnauthorized);
```
